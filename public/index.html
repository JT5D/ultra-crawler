<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Ultra-Crawler Pro</title>
  <script src="https://unpkg.com/3d-force-graph@1.73.4/dist/3d-force-graph.min.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <!-- Three.js for 3D Treemap and Sunburst (use 0.145 for global script compatibility) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/controls/OrbitControls.js"></script>
  <!-- WebXR for AR mode -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.145.0/examples/js/webxr/ARButton.js"></script>
  <!-- PeerJS for multiplayer -->
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <style>
    /* VisionOS Authentic Theme */
    :root {
      /* Physics-based Materials */
      --glass-base: rgba(30, 30, 35, 0.45);
      --glass-border: rgba(255, 255, 255, 0.2);
      --glass-highlight: rgba(255, 255, 255, 0.1);
      --glass-shadow: 0 4px 30px rgba(0, 0, 0, 0.3);

      /* Colors */
      --bg: #000000;
      /* Vibrant System Blue */
      --accent: #007AFF;
      --accent-grad: linear-gradient(180deg, #3395ff, #007aff);
      --text: #ffffff;
      --text-secondary: rgba(235, 235, 245, 0.6);

      /* Geometry */
      --radius-window: 32px;
      --radius-control: 24px;
      --radius-pill: 9999px;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      /* Immersive Background */
      background: radial-gradient(circle at 50% 120%, #1c1c1e, #000000 60%);
      font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", "SF Pro Text", Helvetica, sans-serif;
      color: var(--text);
      height: 100vh;
      overflow: hidden;
      letter-spacing: -0.015em;
      -webkit-font-smoothing: antialiased;
    }

    /* Spatial Layout */
    .app {
      display: grid;
      grid-template-columns: 280px 1fr 340px;
      grid-template-rows: 64px 1fr;
      height: 100vh;
      gap: 20px;
      padding: 24px;
    }

    /* Glass Material Mixin */
    .glass-panel {
      background: var(--glass-base);
      -webkit-backdrop-filter: blur(40px) saturate(180%);
      backdrop-filter: blur(40px) saturate(180%);
      border: 1px solid var(--glass-border);
      box-shadow: var(--glass-shadow), inset 0 0 0 1px var(--glass-highlight);
      border-radius: var(--radius-window);
    }

    /* Ornament Bar (Header) */
    header {
      grid-column: 1 / -1;
      display: flex;
      align-items: center;
      padding: 0 24px;
      gap: 20px;
      z-index: 100;
      background: transparent !important;
      /* Let glass-panel handle it */
    }

    header.glass-panel {
      background: rgba(30, 30, 35, 0.6);
      /* Slightly denser for header */
      border-radius: var(--radius-pill);
      /* Pill shape for ornament */
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
      margin: 0 40px;
      /* Float/inset from edges */
      width: calc(100% - 80px);
    }

    .logo {
      font-size: 1.2rem;
      font-weight: 700;
      background: linear-gradient(135deg, #fff 0%, var(--accent) 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      letter-spacing: -0.03em;
    }

    /* Ornament Control (Tabs) */
    .tabs {
      display: flex;
      background: rgba(0, 0, 0, 0.2);
      padding: 4px;
      border-radius: var(--radius-pill);
      gap: 4px;
      border: 1px solid var(--glass-highlight);
    }

    .tab {
      padding: 8px 16px;
      border: none;
      background: transparent;
      color: var(--text-secondary);
      border-radius: var(--radius-pill);
      cursor: pointer;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.3s cubic-bezier(0.25, 1, 0.5, 1);
    }

    .tab:hover {
      background: var(--glass-highlight);
      color: var(--text);
    }

    .tab.active {
      background: var(--glass-highlight);
      color: #fff;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    /* Search Field (Glass Pill) */
    .search {
      flex: 1;
      max-width: 400px;
      position: relative;
    }

    .search input {
      width: 100%;
      padding: 10px 16px 10px 42px;
      border: 1px solid transparent;
      background: rgba(120, 120, 128, 0.2);
      /* iOS/VisionOS standard fill */
      color: var(--text);
      border-radius: 12px;
      font-size: 15px;
      transition: all 0.2s;
    }

    .search input:focus {
      outline: none;
      background: rgba(120, 120, 128, 0.3);
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.3);
    }

    .search::before {
      content: 'üîç';
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 14px;
      opacity: 0.5;
    }

    /* Circular IconButton (Voice) */
    .voice-btn {
      position: absolute;
      right: 6px;
      top: 50%;
      transform: translateY(-50%);
      background: transparent;
      color: var(--text-secondary);
      border: none;
      cursor: pointer;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
    }

    .voice-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text);
    }

    .voice-btn.listening {
      color: var(--accent-secondary);
      animation: pulse 1.5s infinite;
    }

    /* Platter Buttons (Export, AR, Multi) */
    .btn-glass,
    .export-btn,
    .ar-btn,
    .mp-btn {
      background: rgba(255, 255, 255, 0.1);
      /* Platter fill */
      color: var(--text);
      border: 1px solid transparent;
      /* No border for platters usually */
      padding: 10px 20px;
      border-radius: var(--radius-pill);
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      transition: all 0.2s ease-out;
      display: flex;
      align-items: center;
      gap: 8px;
      height: 36px;
    }

    .btn-glass:hover,
    .export-btn:hover,
    .ar-btn:hover,
    .mp-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.02);
    }

    .btn-glass:hover {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.3);
      transform: translateY(-1px);
    }

    .btn-accent {
      background: var(--accent);
      border: none;
      box-shadow: 0 4px 12px var(--accent-glow);
    }

    .btn-accent:hover {
      background: #409cff;
    }

    /* Map existing classes to new styles MANUALLY (No @extend) */
    .export-btn,
    .ar-btn,
    .mp-btn {
      background: rgba(255, 255, 255, 0.05);
      color: var(--text);
      border: 1px solid var(--glass-border);
      padding: 8px 16px;
      border-radius: var(--radius-btn);
      cursor: pointer;
      font-size: 0.8rem;
      font-weight: 600;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .export-btn:hover,
    .ar-btn:hover,
    .mp-btn:hover {
      background: rgba(255, 255, 255, 0.15);
      transform: translateY(-1px);
    }

    .mp-connected {
      border-color: var(--success);
      color: var(--success);
      background: rgba(48, 209, 88, 0.1);
    }

    /* Dropdowns */
    .dropdown {
      position: absolute;
      top: 120%;
      right: 0;
      background: rgba(30, 30, 35, 0.9);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 16px;
      padding: 8px;
      display: none;
      min-width: 180px;
      z-index: 1000;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      animation: slideDown 0.2s cubic-bezier(0.2, 0.8, 0.2, 1);
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .export-menu,
    .mp-menu {
      display: none;
    }

    /* Override previous */
    .export-menu.visible,
    .mp-menu.visible {
      display: block;
      position: absolute;
      top: 120%;
      right: 0;
      background: rgba(30, 30, 35, 0.9);
      backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 16px;
      padding: 8px;
      z-index: 1000;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
    }

    .export-menu button,
    .mp-menu button {
      width: 100%;
      padding: 10px 14px;
      background: transparent;
      border: none;
      color: var(--text);
      text-align: left;
      cursor: pointer;
      border-radius: 8px;
      font-size: 0.85rem;
      transition: background 0.1s;
    }

    .export-menu button:hover,
    .mp-menu button:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .mp-menu input {
      width: 100%;
      background: rgba(0, 0, 0, 0.4);
      border: 1px solid var(--glass-border);
      color: var(--text);
      padding: 10px;
      border-radius: 12px;
      margin-bottom: 8px;
    }

    /* Sidebar Floating Panel */
    .sidebar {
      grid-row: 2;
      background: var(--glass);
      backdrop-filter: blur(25px);
      -webkit-backdrop-filter: blur(25px);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-panel);
      overflow-y: auto;
      padding: 16px;
    }

    .section {
      margin-bottom: 24px;
    }

    .section-title {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--text-dim);
      margin-bottom: 12px;
      font-weight: 600;
    }

    /* Selects */
    select {
      width: 100%;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid var(--glass-border);
      color: var(--text);
      padding: 8px 12px;
      border-radius: 12px;
      font-size: 0.85rem;
      appearance: none;
      cursor: pointer;
    }

    select:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    /* Button Primary */
    .btn-primary {
      width: 100%;
      background: var(--accent);
      color: white;
      border: none;
      padding: 10px;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      box-shadow: 0 4px 12px var(--accent-glow);
      transition: all 0.2s;
    }

    .btn-primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 16px var(--accent-glow);
    }

    /* Right Panel (Analytics) */
    .right-panel {
      grid-row: 2;
      background: var(--glass);
      backdrop-filter: blur(25px);
      -webkit-backdrop-filter: blur(25px);
      border: 1px solid var(--glass-border);
      border-radius: var(--radius-panel);
      padding: 16px;
      overflow-y: auto;
    }

    /* Analytics Cards */
    .metric-card {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 16px;
      padding: 16px;
      text-align: center;
      margin-bottom: 12px;
    }

    .metric-val {
      font-size: 1.5rem;
      font-weight: 700;
      color: #fff;
      text-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
    }

    .metric-label {
      font-size: 0.75rem;
      color: var(--text-dim);
      margin-top: 4px;
    }

    /* Bars */
    .bar-chart {
      margin-top: 10px;
    }

    /* Fixed lint */
    .bar-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 6px;
    }

    .bar-track {
      flex: 1;
      height: 6px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      overflow: hidden;
    }

    .bar-fill {
      height: 100%;
      border-radius: 3px;
      background: var(--accent);
      box-shadow: 0 0 8px var(--accent-glow);
    }

    .bar-label {
      width: 50px;
      font-size: 0.7rem;
      color: var(--text-dim);
    }

    /* Visualization Area */
    .viz {
      grid-column: 2;
      grid-row: 2;
      position: relative;
      border-radius: var(--radius-panel);
      overflow: hidden;
      box-shadow: 0 0 0 1px var(--glass-border);
      /* Subtle border */
    }

    /* Scrollbars */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    /* Tooltip */
    .tooltip {
      position: fixed;
      background: rgba(20, 20, 25, 0.95);
      backdrop-filter: blur(10px);
      border: 1px solid var(--glass-border);
      border-radius: 12px;
      padding: 12px;
      font-size: 0.8rem;
      pointer-events: none;
      z-index: 2000;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
      opacity: 0;
      transition: opacity 0.15s;
    }

    .tooltip.visible {
      opacity: 1;
    }

    /* Breadcrumbs */
    .breadcrumb {
      position: absolute;
      bottom: 20px;
      left: 20px;
      display: flex;
      gap: 6px;
      z-index: 10;
    }

    .crumb {
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(10px);
      border: 1px solid var(--glass-border);
      padding: 6px 12px;
      border-radius: 12px;
      font-size: 0.75rem;
      cursor: pointer;
      color: var(--text);
      transition: all 0.2s;
    }

    .crumb:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: var(--accent);
    }

    /* Stats in Header */
    .stats {
      display: flex;
      gap: 16px;
      margin-left: auto;
      font-size: 0.75rem;
      color: var(--text-dim);
    }

    .stat-val {
      color: var(--accent);
      font-weight: 600;
      text-shadow: 0 0 10px var(--accent-glow);
    }

    .export-container {
      margin-left: 20px;
      position: relative;
    }

    .multiplayer-container {
      position: relative;
    }

    /* Voice Feedback */
    .voice-feedback {
      background: rgba(20, 20, 25, 0.9);
      backdrop-filter: blur(15px);
      border: 1px solid var(--accent);
      border-radius: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    }
  </style>
</head>

<body>
  <div class="app">
    <header class="glass-panel">
      <div class="logo">‚ö° Ultra-Crawler Pro</div>
      <div class="tabs">
        <button class="tab active" data-view="treemap">Treemap</button>
        <button class="tab" data-view="sunburst">Sunburst</button>
        <button class="tab" data-view="treemap3d">3D Map</button>
        <button class="tab" data-view="sunburst3d">3D Sun</button>
        <button class="tab" data-view="graph3d">3D Graph</button>
      </div>
      <div class="search">
        <input type="text" id="search" placeholder="Search files...">
        <button class="voice-btn" id="voice-btn">üé§</button>
      </div>
      <div class="stats">
        <span><span class="stat-val" id="s-items">0</span> items</span>
        <span><span class="stat-val" id="s-size">0</span></span>
        <span><span class="stat-val" id="s-dirs">0</span> folders</span>
        <span><span class="stat-val" id="s-files">0</span> files</span>
      </div>
      <div class="export-container">
        <button id="export-btn" class="export-btn" title="Export Visualization">üì§ Export</button>
        <div id="export-menu" class="export-menu">
          <button data-export="png">üì∏ PNG Screenshot</button>
          <button data-export="json">üìÑ JSON Data</button>
          <button data-export="csv">üìä CSV Summary</button>
        </div>
      </div>
      <button id="ar-btn" class="ar-btn" title="AR View (requires WebXR device)">ü•Ω AR</button>
      <div class="multiplayer-container">
        <button id="mp-btn" class="mp-btn" title="Multiplayer">üë• Multi</button>
        <div id="mp-menu" class="mp-menu">
          <input type="text" id="mp-room" placeholder="Room code...">
          <button id="mp-create">Create Room</button>
          <button id="mp-join">Join Room</button>
          <div id="mp-status"></div>
        </div>
      </div>
    </header>

    <aside class="sidebar">
      <div class="section">
        <div class="section-title">Quick Crawl</div>
        <div class="form-row">
          <select id="mode">
            <option value="filesystem">üìÅ Filesystem</option>
            <option value="web">üåê Web</option>
            <option value="s3">‚òÅÔ∏è S3</option>
          </select>
        </div>
        <div class="form-row">
          <input type="text" id="path" value="." placeholder="Path">
          <input type="number" id="depth" value="5" min="1" max="20" style="width:50px">
        </div>
        <button class="btn" id="crawl-btn">‚ö° Crawl</button>
      </div>

      <div class="section">
        <div class="section-title">Filter by Type</div>
        <div class="filters" id="filters"></div>
      </div>

      <div class="section">
        <div class="section-title">Search Results</div>
        <div class="file-list" id="results"></div>
      </div>

      <div class="section">
        <div class="section-title">File Extensions</div>
        <div class="bar-chart" id="ext-chart"></div>
      </div>

      <div class="section">
        <div class="section-title">Console</div>
        <div id="console"
          style="background:var(--bg);padding:6px;border-radius:4px;font-family:monospace;font-size:0.65rem;max-height:80px;overflow-y:auto;">
          Ready</div>
      </div>
    </aside>

    <main class="viz">
      <canvas id="viz-canvas"></canvas>
      <div class="breadcrumb" id="breadcrumb"></div>
      <div class="perf" id="perf"></div>
      <div class="loading hidden" id="loading">
        <div class="spinner"></div>
      </div>
    </main>

    <aside class="right-panel">
      <div class="section">
        <div class="section-title">Analytics</div>
        <div class="analytics">
          <div class="metric">
            <div class="metric-value" id="m-avg">0</div>
            <div class="metric-label">Avg Size</div>
          </div>
          <div class="metric">
            <div class="metric-value" id="m-median">0</div>
            <div class="metric-label">Median</div>
          </div>
          <div class="metric">
            <div class="metric-value" id="m-depth">0</div>
            <div class="metric-label">Max Depth</div>
          </div>
          <div class="metric">
            <div class="metric-value" id="m-types">0</div>
            <div class="metric-label">File Types</div>
          </div>
        </div>
      </div>

      <div class="section">
        <div class="section-title">üìä Size Distribution</div>
        <div class="mini-chart" id="size-dist"></div>
      </div>

      <div class="section">
        <div class="section-title">üî• Largest Files</div>
        <div id="top-files"></div>
      </div>

      <div class="section">
        <div class="section-title">üìÅ Largest Folders</div>
        <div id="top-dirs"></div>
      </div>

      <div class="section">
        <div class="section-title">üïí Recently Modified</div>
        <div id="recent-files"></div>
      </div>

      <div class="section">
        <div class="section-title">‚ö†Ô∏è Duplicates</div>
        <div id="duplicates"></div>
      </div>
    </aside>
  </div>

  <div class="tooltip" id="tooltip"></div>

  <script>
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PERFORMANCE-OPTIMIZED ULTRA-CRAWLER PRO
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const $ = id => document.getElementById(id);
    const formatBytes = b => { if (!b) return '0 B'; const k = 1024, s = ['B', 'KB', 'MB', 'GB', 'TB']; const i = Math.floor(Math.log(b) / Math.log(k)); return (b / Math.pow(k, i)).toFixed(1) + ' ' + s[i]; };
    const formatNum = n => n?.toLocaleString() || '0';

    const COLORS = {
      '.js': '#f0db4f', '.ts': '#3178c6', '.jsx': '#61dafb', '.tsx': '#3178c6',
      '.py': '#3572A5', '.rb': '#CC342D', '.go': '#00ADD8', '.rs': '#dea584',
      '.html': '#e34c26', '.css': '#563d7c', '.scss': '#c6538c',
      '.json': '#3fb950', '.yaml': '#cb171e', '.yml': '#cb171e', '.xml': '#f80',
      '.md': '#f78166', '.txt': '#8b949e',
      '.jpg': '#d63aff', '.png': '#d63aff', '.gif': '#d63aff', '.svg': '#ffb13b',
      '.mp4': '#ff6b6b', '.mp3': '#1ed760',
      '.pdf': '#f40f02', '.zip': '#ffc107',
      'directory': '#58a6ff', 'default': '#8b949e'
    };
    const getColor = (type, ext) => COLORS[ext] || COLORS[type] || COLORS.default;
    const getIcon = (type, ext) => {
      if (type === 'directory') return 'üìÅ';
      const icons = { '.js': 'üìú', '.ts': 'üìú', '.py': 'üêç', '.html': 'üåê', '.css': 'üé®', '.json': 'üìã', '.md': 'üìù', '.jpg': 'üñºÔ∏è', '.png': 'üñºÔ∏è', '.pdf': 'üìï', '.mp4': 'üé¨', '.mp3': 'üéµ', '.zip': 'üì¶' };
      return icons[ext] || 'üìÑ';
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // STATE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    let data = null, flatNodes = [], hierarchy = null, currentView = 'treemap', currentRoot = null;
    let activeFilters = new Set(), graph3D = null;
    const canvas = $('viz-canvas'), ctx = canvas.getContext('2d');
    let renderCache = new Map(), layoutCache = null;

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CANVAS RENDERER (Much faster than SVG for large datasets)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function resizeCanvas() {
      const rect = canvas.parentElement.getBoundingClientRect();
      canvas.width = rect.width * devicePixelRatio;
      canvas.height = rect.height * devicePixelRatio;
      canvas.style.width = rect.width + 'px';
      canvas.style.height = rect.height + 'px';
      ctx.scale(devicePixelRatio, devicePixelRatio);
    }

    function renderTreemapCanvas(root) {
      const start = performance.now();
      const w = canvas.width / devicePixelRatio, h = canvas.height / devicePixelRatio;
      ctx.clearRect(0, 0, w, h);

      const d3Root = d3.hierarchy(root).sum(d => d.size || 1).sort((a, b) => b.value - a.value);
      d3.treemap().size([w, h]).paddingOuter(2).paddingTop(16).paddingInner(1).round(true)(d3Root);

      layoutCache = d3Root.descendants().filter(d => d.depth > 0 && d.depth <= 4);

      // Batch render with requestAnimationFrame chunks
      const renderBatch = (nodes, idx = 0) => {
        const batchSize = 500;
        const end = Math.min(idx + batchSize, nodes.length);

        for (let i = idx; i < end; i++) {
          const d = nodes[i];
          const w = d.x1 - d.x0, h = d.y1 - d.y0;
          if (w < 1 || h < 1) continue;

          ctx.fillStyle = getColor(d.data.type, d.data.ext);
          ctx.globalAlpha = d.children ? 0.6 : 0.85;
          ctx.fillRect(d.x0, d.y0, w, h);

          // Labels for visible nodes
          if (w > 40 && h > 14) {
            ctx.globalAlpha = 1;
            ctx.fillStyle = '#fff';
            ctx.font = '10px -apple-system, sans-serif';
            const label = (d.children ? 'üìÅ ' : '') + d.data.name;
            const maxChars = Math.floor((w - 8) / 6);
            ctx.fillText(label.slice(0, maxChars), d.x0 + 4, d.y0 + 12);

            // Size label
            if (h > 26 && !d.children) {
              ctx.fillStyle = 'rgba(255,255,255,0.7)';
              ctx.font = '9px monospace';
              ctx.fillText(formatBytes(d.value), d.x0 + 4, d.y0 + 24);
            }
          }
        }
        ctx.globalAlpha = 1;

        if (end < nodes.length) {
          requestAnimationFrame(() => renderBatch(nodes, end));
        } else {
          showPerf(performance.now() - start, nodes.length);
        }
      };

      renderBatch(layoutCache);
      currentRoot = root;
    }

    function renderSunburstCanvas(root) {
      const start = performance.now();
      const w = canvas.width / devicePixelRatio, h = canvas.height / devicePixelRatio;
      const radius = Math.min(w, h) / 2 - 10;
      const cx = w / 2, cy = h / 2;

      ctx.clearRect(0, 0, w, h);

      const d3Root = d3.hierarchy(root).sum(d => d.size || 1).sort((a, b) => b.value - a.value);
      d3.partition().size([2 * Math.PI, radius])(d3Root);

      layoutCache = d3Root.descendants().filter(d => d.depth > 0 && d.depth <= 6);

      for (const d of layoutCache) {
        const innerR = d.y0, outerR = d.y1;
        ctx.beginPath();
        ctx.arc(cx, cy, outerR, d.x0 - Math.PI / 2, d.x1 - Math.PI / 2);
        ctx.arc(cx, cy, innerR, d.x1 - Math.PI / 2, d.x0 - Math.PI / 2, true);
        ctx.closePath();
        ctx.fillStyle = getColor(d.data.type, d.data.ext);
        ctx.globalAlpha = d.children ? 0.7 : 0.9;
        ctx.fill();
      }
      ctx.globalAlpha = 1;

      // Center
      ctx.beginPath();
      ctx.arc(cx, cy, d3Root.y0 || 20, 0, 2 * Math.PI);
      ctx.fillStyle = '#161b22';
      ctx.fill();
      ctx.fillStyle = '#8b949e';
      ctx.font = '11px -apple-system';
      ctx.textAlign = 'center';
      ctx.fillText(root.name || 'Root', cx, cy + 4);
      ctx.textAlign = 'left';

      showPerf(performance.now() - start, layoutCache.length);
    }

    function renderFlameCanvas(root) {
      const start = performance.now();
      const w = canvas.width / devicePixelRatio, h = canvas.height / devicePixelRatio;

      ctx.clearRect(0, 0, w, h);

      const d3Root = d3.hierarchy(root).sum(d => d.size || 1).sort((a, b) => b.value - a.value);
      d3.partition().size([w, h]).padding(1)(d3Root);

      layoutCache = d3Root.descendants().filter(d => d.depth <= 8);

      for (const d of layoutCache) {
        const bw = d.x1 - d.x0, bh = d.y1 - d.y0;
        if (bw < 1) continue;

        ctx.fillStyle = getColor(d.data.type, d.data.ext);
        ctx.globalAlpha = d.children ? 0.7 : 0.9;
        ctx.fillRect(d.x0, d.y0, bw, bh);

        if (bw > 30) {
          ctx.globalAlpha = 1;
          ctx.fillStyle = '#fff';
          ctx.font = '9px -apple-system';
          ctx.fillText(d.data.name.slice(0, Math.floor(bw / 5)), d.x0 + 2, d.y0 + 10);
        }
      }
      ctx.globalAlpha = 1;
      showPerf(performance.now() - start, layoutCache.length);
    }

    function render3D(root) {
      const el = canvas.parentElement;
      canvas.style.display = 'none';

      let container = $('graph3d-container');
      if (!container) {
        container = document.createElement('div');
        container.id = 'graph3d-container';
        container.style.cssText = 'position:absolute;inset:0;';
        el.appendChild(container);
      }
      container.innerHTML = '';
      container.style.display = 'block';

      const nodes = [], links = [];
      let id = 0;

      // AGGRESSIVE PERFORMANCE: Much lower limits for smooth 60fps
      const MAX_NODES = 500;   // Dramatically reduced for 60fps
      const MAX_CHILDREN = 20; // Fewer children per node
      const MAX_DEPTH = 3;     // Shallower traversal

      const traverse = (node, parentId = null, depth = 0) => {
        if (nodes.length >= MAX_NODES) return;
        if (depth > MAX_DEPTH) return;

        const nid = id++;
        nodes.push({
          id: nid,
          name: node.name,
          color: getColor(node.type, node.ext),
          val: Math.log10(Math.max(node.size || 1, 1)) + 1
        });

        if (parentId !== null) links.push({ source: parentId, target: nid });
        (node.children || []).slice(0, MAX_CHILDREN).forEach(c => traverse(c, nid, depth + 1));
      };
      traverse(root);

      console.log(`üéÆ 3D Graph: ${nodes.length} nodes (max: ${MAX_NODES})`);

      // ULTRA-OPTIMIZED ForceGraph3D
      graph3D = ForceGraph3D({ controlType: 'orbit' })(container)
        .graphData({ nodes, links })
        .nodeLabel(n => n.name)
        .nodeColor(n => n.color)
        .nodeVal(n => n.val)
        .nodeOpacity(0.85)
        .nodeResolution(4)         // Very low poly (default: 8)
        .linkColor(() => 'rgba(88,166,255,0.1)')
        .linkWidth(0.1)
        .linkOpacity(0.2)
        .backgroundColor('#0d1117')
        // ULTRA PERFORMANCE
        .warmupTicks(30)           // Fewer warmup ticks
        .cooldownTicks(0)          // No post-warmup animation
        .d3AlphaDecay(0.1)         // Very fast settling
        .d3VelocityDecay(0.5)      // High damping
        .linkDirectionalParticles(0)
        .enableNodeDrag(false)
        .enablePointerInteraction(false) // Disable hover effects
        .showNavInfo(false);

      // Immediately pause after brief warmup
      setTimeout(() => {
        if (graph3D) {
          graph3D.pauseAnimation();
          showPerf(0, nodes.length);
        }
      }, 500);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 3D TREEMAP (Three.js nested cubes with depth)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    let scene3D, camera3D, renderer3D, controls3D, animateId3D;

    function cleanup3D() {
      if (animateId3D) cancelAnimationFrame(animateId3D);
      if (renderer3D) renderer3D.dispose();
      const container = $('threejs-container');
      if (container) container.innerHTML = '';
    }

    function render3DTreemap(root) {
      const start = performance.now();
      canvas.style.display = 'none';
      hide3DGraph();

      let container = $('threejs-container');
      if (!container) {
        container = document.createElement('div');
        container.id = 'threejs-container';
        container.style.cssText = 'position:absolute;inset:0;';
        canvas.parentElement.appendChild(container);
      }
      cleanup3D();
      container.style.display = 'block';

      // Setup Three.js scene
      scene3D = new THREE.Scene();
      scene3D.background = new THREE.Color(0x0d1117);

      const rect = container.getBoundingClientRect();
      camera3D = new THREE.PerspectiveCamera(60, rect.width / rect.height, 0.1, 1000);
      camera3D.position.set(0, 50, 80);

      // PERFORMANCE: Disable antialiasing, limit pixel ratio
      renderer3D = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
      renderer3D.setSize(rect.width, rect.height);
      renderer3D.setPixelRatio(1); // Fixed pixel ratio for performance
      container.appendChild(renderer3D.domElement);

      controls3D = new THREE.OrbitControls(camera3D, renderer3D.domElement);
      controls3D.enableDamping = true;
      controls3D.dampingFactor = 0.1;
      controls3D.rotateSpeed = 0.5;

      // Build treemap layout
      const d3Root = d3.hierarchy(root).sum(d => d.size || 1).sort((a, b) => b.value - a.value);
      const TREEMAP_SIZE = 80;
      d3.treemap().size([TREEMAP_SIZE, TREEMAP_SIZE]).paddingOuter(1).paddingTop(2).paddingInner(0.5)(d3Root);

      // PERFORMANCE: Limit depth and total nodes
      const MAX_DEPTH = 2;
      const MAX_CUBES = 300;
      let nodes = d3Root.descendants().filter(d => d.depth > 0 && d.depth <= MAX_DEPTH);
      nodes = nodes.slice(0, MAX_CUBES);

      // Create cubes with simpler materials
      nodes.forEach(d => {
        const w = d.x1 - d.x0;
        const h = d.y1 - d.y0;
        if (w < 1 || h < 1) return;

        const height = Math.max(1, Math.log10(d.value + 1) * 3);
        const geo = new THREE.BoxGeometry(w * 0.95, height, h * 0.95);
        const color = new THREE.Color(getColor(d.data.type, d.data.ext));
        const mat = new THREE.MeshLambertMaterial({
          color,
          transparent: true,
          opacity: d.children ? 0.4 : 0.85
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.set(
          (d.x0 + d.x1) / 2 - TREEMAP_SIZE / 2,
          height / 2 + d.depth * 2,
          (d.y0 + d.y1) / 2 - TREEMAP_SIZE / 2
        );
        mesh.userData = { name: d.data.name, size: d.data.size, type: d.data.type };
        scene3D.add(mesh);
      });

      // Lights
      scene3D.add(new THREE.AmbientLight(0xffffff, 0.6));
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(50, 100, 50);
      scene3D.add(dirLight);

      // Animate
      function animate() {
        animateId3D = requestAnimationFrame(animate);
        controls3D.update();
        renderer3D.render(scene3D, camera3D);
      }
      animate();

      showPerf(performance.now() - start, nodes.length);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // 3D SUNBURST (Three.js concentric shells)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function render3DSunburst(root) {
      const start = performance.now();
      canvas.style.display = 'none';
      hide3DGraph();

      let container = $('threejs-container');
      if (!container) {
        container = document.createElement('div');
        container.id = 'threejs-container';
        container.style.cssText = 'position:absolute;inset:0;';
        canvas.parentElement.appendChild(container);
      }
      cleanup3D();
      container.style.display = 'block';

      scene3D = new THREE.Scene();
      scene3D.background = new THREE.Color(0x0d1117);

      const rect = container.getBoundingClientRect();
      camera3D = new THREE.PerspectiveCamera(60, rect.width / rect.height, 0.1, 1000);
      camera3D.position.set(0, 40, 60);

      // PERFORMANCE: Disable antialiasing
      renderer3D = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
      renderer3D.setSize(rect.width, rect.height);
      renderer3D.setPixelRatio(1);
      container.appendChild(renderer3D.domElement);

      controls3D = new THREE.OrbitControls(camera3D, renderer3D.domElement);
      controls3D.enableDamping = true;
      controls3D.dampingFactor = 0.1;

      // Build partition layout
      const d3Root = d3.hierarchy(root).sum(d => d.size || 1).sort((a, b) => b.value - a.value);
      d3.partition().size([2 * Math.PI, 30])(d3Root);

      // PERFORMANCE: Lower limits
      const MAX_DEPTH = 2;
      const MAX_ARCS = 200;
      let nodes = d3Root.descendants().filter(d => d.depth > 0 && d.depth <= MAX_DEPTH);
      nodes = nodes.slice(0, MAX_ARCS);

      // Create simplified arc segments
      nodes.forEach(d => {
        const innerR = d.y0;
        const outerR = d.y1;
        const startAngle = d.x0;
        const endAngle = d.x1;

        if (endAngle - startAngle < 0.05) return; // Skip tiny arcs

        // Create ring segment shape
        const shape = new THREE.Shape();
        const segments = Math.max(3, Math.floor((endAngle - startAngle) * 8));

        // Outer arc
        for (let i = 0; i <= segments; i++) {
          const theta = startAngle + (endAngle - startAngle) * (i / segments);
          const x = Math.cos(theta) * outerR;
          const z = Math.sin(theta) * outerR;
          if (i === 0) shape.moveTo(x, z);
          else shape.lineTo(x, z);
        }
        // Inner arc (reverse)
        for (let i = segments; i >= 0; i--) {
          const theta = startAngle + (endAngle - startAngle) * (i / segments);
          const x = Math.cos(theta) * innerR;
          const z = Math.sin(theta) * innerR;
          shape.lineTo(x, z);
        }
        shape.closePath();

        const depth = Math.max(0.5, Math.log10(d.value + 1) * 0.8);
        const geo = new THREE.ExtrudeGeometry(shape, { depth, bevelEnabled: false });
        const color = new THREE.Color(getColor(d.data.type, d.data.ext));
        const mat = new THREE.MeshLambertMaterial({
          color,
          transparent: true,
          opacity: d.children ? 0.5 : 0.9
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.rotation.x = -Math.PI / 2;
        mesh.position.y = d.depth * 2;
        mesh.userData = { name: d.data.name, size: d.data.size };
        scene3D.add(mesh);
      });

      // Lights
      scene3D.add(new THREE.AmbientLight(0xffffff, 0.6));
      const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dirLight.position.set(30, 80, 30);
      scene3D.add(dirLight);

      function animate() {
        animateId3D = requestAnimationFrame(animate);
        controls3D.update();
        renderer3D.render(scene3D, camera3D);
      }
      animate();

      showPerf(performance.now() - start, nodes.length);
    }

    function hide3DGraph() {
      const container = $('graph3d-container');
      if (container) container.style.display = 'none';
      if (graph3D) graph3D = null;
    }

    function hideThreejs() {
      cleanup3D();
      const container = $('threejs-container');
      if (container) container.style.display = 'none';
    }

    function showPerf(ms, count) {
      const perf = $('perf');
      perf.textContent = `${ms.toFixed(1)}ms ‚Ä¢ ${formatNum(count)} nodes`;
      perf.className = 'perf ' + (ms < 100 ? 'fast' : 'slow');
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ANALYTICS
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function computeAnalytics(nodes) {
      const files = nodes.filter(n => n.type !== 'directory' && n.size > 0);
      const dirs = nodes.filter(n => n.type === 'directory');
      const sizes = files.map(f => f.size).sort((a, b) => a - b);
      const totalSize = sizes.reduce((a, b) => a + b, 0);

      // Stats
      $('s-items').textContent = formatNum(nodes.length);
      $('s-size').textContent = formatBytes(totalSize);
      $('s-dirs').textContent = formatNum(dirs.length);
      $('s-files').textContent = formatNum(files.length);

      // Metrics
      $('m-avg').textContent = formatBytes(totalSize / files.length || 0);
      $('m-median').textContent = formatBytes(sizes[Math.floor(sizes.length / 2)] || 0);
      $('m-depth').textContent = Math.max(...nodes.map(n => n.depth || 0), 0);
      const exts = new Set(files.map(f => f.ext).filter(Boolean));
      $('m-types').textContent = exts.size;

      // Extension chart
      const extCounts = {};
      files.forEach(f => { if (f.ext) extCounts[f.ext] = (extCounts[f.ext] || 0) + 1; });
      const sorted = Object.entries(extCounts).sort((a, b) => b[1] - a[1]).slice(0, 10);
      const maxCount = sorted[0]?.[1] || 1;

      $('ext-chart').innerHTML = sorted.map(([ext, count]) => `
        <div class="bar-row">
          <span class="bar-label">${ext}</span>
          <div class="bar-track"><div class="bar-fill" style="width:${count / maxCount * 100}%;background:${COLORS[ext] || COLORS.default}"></div></div>
          <span class="bar-count">${formatNum(count)}</span>
        </div>
      `).join('');

      // Filters
      $('filters').innerHTML = Array.from(exts).slice(0, 12).map(ext => `
        <div class="filter-chip${activeFilters.has(ext) ? ' active' : ''}" data-ext="${ext}">
          <span class="dot" style="background:${COLORS[ext] || COLORS.default}"></span>${ext}
        </div>
      `).join('');

      // Size distribution
      const buckets = new Array(20).fill(0);
      const maxSize = Math.max(...sizes, 1);
      files.forEach(f => { const i = Math.min(19, Math.floor(f.size / maxSize * 19)); buckets[i]++; });
      const maxBucket = Math.max(...buckets, 1);
      $('size-dist').innerHTML = buckets.map((c, i) =>
        `<div class="mini-bar" style="left:${i * 5}%;width:4%;height:${c / maxBucket * 100}%"></div>`
      ).join('');

      // Top files
      const topFiles = [...files].sort((a, b) => b.size - a.size).slice(0, 8);
      $('top-files').innerHTML = topFiles.map((f, i) => `
        <div class="top-file"><span class="top-rank">${i + 1}</span><span class="top-name" title="${f.path}">${f.name}</span><span class="top-size">${formatBytes(f.size)}</span></div>
      `).join('');

      // Top dirs
      const topDirs = [...dirs].filter(d => d.size > 0).sort((a, b) => b.size - a.size).slice(0, 6);
      $('top-dirs').innerHTML = topDirs.map((d, i) => `
        <div class="top-file"><span class="top-rank">${i + 1}</span><span class="top-name" title="${d.path}">üìÅ ${d.name}</span><span class="top-size">${formatBytes(d.size)}</span></div>
      `).join('');

      // Recent files
      const recent = [...files].filter(f => f.modifiedAt).sort((a, b) => (b.modifiedAt || 0) - (a.modifiedAt || 0)).slice(0, 5);
      $('recent-files').innerHTML = recent.map(f => {
        const ago = Date.now() - (f.modifiedAt || 0);
        const when = ago < 3600000 ? Math.floor(ago / 60000) + 'm' : ago < 86400000 ? Math.floor(ago / 3600000) + 'h' : Math.floor(ago / 86400000) + 'd';
        return `<div class="top-file"><span class="top-name">${f.name}</span><span class="top-size">${when} ago</span></div>`;
      }).join('') || '<div style="color:var(--dim)">No recent data</div>';

      // Duplicates by name
      const nameCounts = {};
      files.forEach(f => { nameCounts[f.name] = (nameCounts[f.name] || 0) + 1; });
      const dupes = Object.entries(nameCounts).filter(([, c]) => c > 1).sort((a, b) => b[1] - a[1]).slice(0, 5);
      $('duplicates').innerHTML = dupes.map(([name, count]) =>
        `<div class="top-file"><span class="top-name">${name}</span><span class="top-size">√ó${count}</span></div>`
      ).join('') || '<div style="color:var(--dim)">No duplicates</div>';
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // INTERACTION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const tooltip = $('tooltip');
    let hoveredNode = null;

    canvas.addEventListener('mousemove', e => {
      if (!layoutCache) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left, y = e.clientY - rect.top;

      hoveredNode = null;
      for (const d of layoutCache) {
        if (x >= d.x0 && x <= d.x1 && y >= d.y0 && y <= d.y1) {
          hoveredNode = d;
          break;
        }
      }

      if (hoveredNode) {
        const n = hoveredNode.data;
        tooltip.innerHTML = `
          <div class="tooltip-title">${getIcon(n.type, n.ext)} ${n.name}</div>
          <div class="tooltip-row"><span class="tooltip-label">Type</span><span>${n.type}</span></div>
          <div class="tooltip-row"><span class="tooltip-label">Size</span><span>${formatBytes(hoveredNode.value || n.size)}</span></div>
          ${n.ext ? `<div class="tooltip-row"><span class="tooltip-label">Ext</span><span>${n.ext}</span></div>` : ''}
          ${hoveredNode.children ? `<div class="tooltip-row"><span class="tooltip-label">Items</span><span>${hoveredNode.children.length}</span></div>` : ''}
        `;
        tooltip.style.left = (e.pageX + 12) + 'px';
        tooltip.style.top = (e.pageY + 12) + 'px';
        tooltip.classList.add('visible');
        canvas.style.cursor = 'pointer';
      } else {
        tooltip.classList.remove('visible');
        canvas.style.cursor = 'default';
      }
    });

    canvas.addEventListener('click', () => {
      if (hoveredNode?.children && currentView === 'treemap') {
        zoomTo(hoveredNode.data);
      }
    });

    canvas.addEventListener('mouseleave', () => tooltip.classList.remove('visible'));

    function zoomTo(node) {
      updateBreadcrumb(node);
      renderTreemapCanvas(node);
    }

    function updateBreadcrumb(node) {
      const crumbs = [];
      let current = node;
      while (current) {
        crumbs.unshift(current);
        current = current.parent;
      }
      $('breadcrumb').innerHTML = `<div class="crumb" onclick="resetView()">üè†</div>` +
        crumbs.slice(0, 5).map((n, i) => `<div class="crumb">${n.name?.slice(0, 15) || 'root'}</div>`).join('');
    }

    window.resetView = () => { if (hierarchy) switchView(currentView); };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // SEARCH (Debounced)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    let searchTimeout;
    $('search').addEventListener('input', e => {
      clearTimeout(searchTimeout);
      searchTimeout = setTimeout(() => search(e.target.value), 150);
    });

    function search(query) {
      if (!query || !flatNodes.length) { $('results').innerHTML = ''; return; }
      const q = query.toLowerCase();
      const matches = flatNodes.filter(n => n.name?.toLowerCase().includes(q)).slice(0, 25);
      $('results').innerHTML = matches.map(n => `
        <div class="file-item"><span class="file-icon">${getIcon(n.type, n.ext)}</span><span class="file-name">${n.name}</span><span class="file-size">${formatBytes(n.size)}</span></div>
      `).join('');
    }

    // Keyboard shortcut
    document.addEventListener('keydown', e => {
      if ((e.metaKey || e.ctrlKey) && e.key === 'k') { e.preventDefault(); $('search').focus(); }
      if (e.key === 'Escape') { tooltip.classList.remove('visible'); $('search').blur(); }
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // FILTERS
    // ‚ïê‚ïê ‚ïê ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    $('filters').addEventListener('click', e => {
      const chip = e.target.closest('.filter-chip');
      if (!chip) return;
      const ext = chip.dataset.ext;
      if (activeFilters.has(ext)) activeFilters.delete(ext);
      else activeFilters.add(ext);
      chip.classList.toggle('active');
      applyFilters();
    });

    function applyFilters() {
      if (!hierarchy) return;
      if (activeFilters.size === 0) {
        switchView(currentView);
        return;
      }
      // Filter hierarchy
      const filterNode = node => {
        if (node.type !== 'directory') {
          return activeFilters.has(node.ext) ? { ...node } : null;
        }
        const children = (node.children || []).map(filterNode).filter(Boolean);
        if (children.length === 0) return null;
        return { ...node, children };
      };
      const filtered = filterNode(hierarchy);
      if (filtered) {
        if (currentView === 'treemap') renderTreemapCanvas(filtered);
        else if (currentView === 'sunburst') renderSunburstCanvas(filtered);
        else if (currentView === 'flame') renderFlameCanvas(filtered);
      }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // VIEW SWITCHING
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function switchView(view) {
      currentView = view;
      document.querySelectorAll('.tab').forEach(t => t.classList.toggle('active', t.dataset.view === view));

      // Hide all 3D containers
      const container3d = $('graph3d-container');
      if (container3d) container3d.style.display = 'none';
      hideThreejs();

      // Show canvas for 2D views
      const is3DView = ['treemap3d', 'sunburst3d', 'graph3d'].includes(view);
      canvas.style.display = is3DView ? 'none' : 'block';

      $('breadcrumb').innerHTML = '<div class="crumb">üè† Root</div>';

      if (!hierarchy) return;

      if (!is3DView) resizeCanvas();

      switch (view) {
        case 'treemap': renderTreemapCanvas(hierarchy); break;
        case 'sunburst': renderSunburstCanvas(hierarchy); break;
        case 'flame': renderFlameCanvas(hierarchy); break;
        case 'treemap3d': render3DTreemap(hierarchy); break;
        case 'sunburst3d': render3DSunburst(hierarchy); break;
        case 'graph3d': hideThreejs(); render3D(hierarchy); break;
      }
    }

    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => switchView(tab.dataset.view));
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // WEBSOCKET & DATA LOADING
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    let ws = null;

    function log(msg) {
      const el = $('console');
      el.innerHTML += `<div>${msg}</div>`;
      el.scrollTop = el.scrollHeight;
    }

    function connectWS() {
      ws = new WebSocket(`ws://${location.host}`);
      ws.onmessage = e => {
        const msg = JSON.parse(e.data);
        if (msg.type === 'log') log(msg.data);
        else if (msg.type === 'error') log(`‚ùå ${msg.data}`);
        else if (msg.type === 'complete') {
          log('‚úÖ Done!');
          $('crawl-btn').disabled = false;
          $('loading').classList.add('hidden');
          if (msg.graph) loadData(msg.graph);
        }
      };
      ws.onclose = () => setTimeout(connectWS, 2000);
    }

    async function loadData(graph = null) {
      $('loading').classList.remove('hidden');
      try {
        if (!graph) {
          const res = await fetch('/api/graph');
          graph = await res.json();
        }
        if (graph?.hierarchy?.[0]) {
          hierarchy = graph.hierarchy[0];
          flatNodes = flattenHierarchy(hierarchy);
          computeAnalytics(flatNodes);
          switchView(currentView);
        }
      } catch (err) {
        log('No data yet');
      }
      $('loading').classList.add('hidden');
    }

    function flattenHierarchy(node, arr = []) {
      arr.push(node);
      (node.children || []).forEach(c => flattenHierarchy(c, arr));
      return arr;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CRAWL
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    $('crawl-btn').addEventListener('click', () => {
      const msg = { type: 'crawl', mode: $('mode').value, depth: $('depth').value, path: $('path').value };
      ws.send(JSON.stringify(msg));
      $('crawl-btn').disabled = true;
      $('loading').classList.remove('hidden');
      log('‚ö° Crawling...');
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // INIT
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    window.addEventListener('resize', () => { resizeCanvas(); if (hierarchy) switchView(currentView); });
    resizeCanvas();
    connectWS();
    loadData();

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // VOICE SEARCH (Web Speech API)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;
    let isListening = false;

    // Create voice feedback element
    const voiceFeedback = document.createElement('div');
    voiceFeedback.className = 'voice-feedback';
    voiceFeedback.id = 'voice-feedback';
    document.body.appendChild(voiceFeedback);

    function showVoiceFeedback(text, duration = 2000) {
      voiceFeedback.textContent = text;
      voiceFeedback.classList.add('visible');
      setTimeout(() => voiceFeedback.classList.remove('visible'), duration);
    }

    function parseVoiceCommand(transcript) {
      const text = transcript.toLowerCase().trim();
      console.log('üé§ Voice:', text);

      // View switching commands
      if (text.includes('treemap') && text.includes('3d')) {
        showVoiceFeedback('üó∫Ô∏è Switching to 3D Treemap');
        switchView('treemap3d');
        return;
      }
      if (text.includes('sunburst') && text.includes('3d')) {
        showVoiceFeedback('‚òÄÔ∏è Switching to 3D Sunburst');
        switchView('sunburst3d');
        return;
      }
      if (text.includes('graph') || text.includes('force')) {
        showVoiceFeedback('üîó Switching to 3D Graph');
        switchView('graph3d');
        return;
      }
      if (text.includes('treemap')) {
        showVoiceFeedback('üìä Switching to Treemap');
        switchView('treemap');
        return;
      }
      if (text.includes('sunburst')) {
        showVoiceFeedback('‚òÄÔ∏è Switching to Sunburst');
        switchView('sunburst');
        return;
      }
      if (text.includes('icicle') || text.includes('flame')) {
        showVoiceFeedback('‚ùÑÔ∏è Switching to Icicle');
        switchView('flame');
        return;
      }

      // Search commands
      if (text.startsWith('search ') || text.startsWith('find ') || text.startsWith('look for ')) {
        const query = text.replace(/^(search|find|look for)\s+/, '');
        $('search').value = query;
        $('search').dispatchEvent(new Event('input'));
        showVoiceFeedback(`üîç Searching: ${query}`);
        return;
      }

      // Crawl commands
      if (text.includes('crawl') || text.includes('scan')) {
        $('crawl-btn').click();
        showVoiceFeedback('‚ö° Starting crawl...');
        return;
      }

      // Default: use as search
      $('search').value = text;
      $('search').dispatchEvent(new Event('input'));
      showVoiceFeedback(`üîç Searching: ${text}`);
    }

    function startVoice() {
      if (!SpeechRecognition) {
        showVoiceFeedback('‚ùå Voice not supported in this browser');
        return;
      }

      if (isListening) {
        recognition.stop();
        return;
      }

      recognition = new SpeechRecognition();
      recognition.continuous = false;
      recognition.interimResults = false;
      recognition.lang = 'en-US';

      recognition.onstart = () => {
        isListening = true;
        $('voice-btn').classList.add('listening');
        showVoiceFeedback('üé§ Listening...', 10000);
      };

      recognition.onresult = (event) => {
        const transcript = event.results[0][0].transcript;
        parseVoiceCommand(transcript);
      };

      recognition.onerror = (event) => {
        console.error('Voice error:', event.error);
        showVoiceFeedback(`‚ùå ${event.error}`);
      };

      recognition.onend = () => {
        isListening = false;
        $('voice-btn').classList.remove('listening');
      };

      recognition.start();
    }

    // Voice button click
    $('voice-btn').addEventListener('click', startVoice);

    // Keyboard shortcut: V for voice
    document.addEventListener('keydown', (e) => {
      if (e.key === 'v' && !e.metaKey && !e.ctrlKey && document.activeElement.tagName !== 'INPUT') {
        e.preventDefault();
        startVoice();
      }
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // EXPORT FUNCTIONALITY
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    function downloadFile(filename, content, type = 'text/plain') {
      const blob = new Blob([content], { type });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      a.click();
      URL.revokeObjectURL(url);
    }

    async function exportPNG() {
      const vizArea = document.querySelector('.viz-area');
      const container3d = $('graph3d-container');
      const threejsContainer = $('threejs-container');

      let targetCanvas;
      if (container3d && container3d.style.display !== 'none') {
        targetCanvas = container3d.querySelector('canvas');
      } else if (threejsContainer && threejsContainer.style.display !== 'none') {
        targetCanvas = threejsContainer.querySelector('canvas');
      } else {
        targetCanvas = canvas;
      }

      if (targetCanvas) {
        const dataUrl = targetCanvas.toDataURL('image/png');
        const a = document.createElement('a');
        a.href = dataUrl;
        a.download = `ultra-crawler-${currentView}-${Date.now()}.png`;
        a.click();
        showVoiceFeedback('üì∏ PNG exported!');
      }
    }

    function exportJSON() {
      if (!hierarchy) {
        showVoiceFeedback('‚ùå No data to export');
        return;
      }
      const json = JSON.stringify(hierarchy, null, 2);
      downloadFile(`ultra-crawler-data-${Date.now()}.json`, json, 'application/json');
      showVoiceFeedback('üìÑ JSON exported!');
    }

    function exportCSV() {
      if (!flatNodes || flatNodes.length === 0) {
        showVoiceFeedback('‚ùå No data to export');
        return;
      }
      const header = 'name,type,size,extension,path\n';
      const rows = flatNodes.slice(0, 10000).map(n =>
        `"${n.name}","${n.type}",${n.size || 0},"${n.ext || ''}","${(n.path || '').replace(/"/g, '""')}"`
      ).join('\n');
      downloadFile(`ultra-crawler-summary-${Date.now()}.csv`, header + rows, 'text/csv');
      showVoiceFeedback('üìä CSV exported!');
    }

    // Export button toggle
    $('export-btn').addEventListener('click', () => {
      $('export-menu').classList.toggle('visible');
    });

    // Export menu items
    document.querySelectorAll('[data-export]').forEach(btn => {
      btn.addEventListener('click', () => {
        const type = btn.dataset.export;
        $('export-menu').classList.remove('visible');
        if (type === 'png') exportPNG();
        else if (type === 'json') exportJSON();
        else if (type === 'csv') exportCSV();
      });
    });

    // Close menu on outside click
    // Close menu on outside click
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.export-container')) {
        $('export-menu').classList.remove('visible');
      }
      if (!e.target.closest('.multiplayer-container') && !e.target.closest('.mp-menu')) {
        $('mp-menu').classList.remove('visible');
      }
    });

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MULTIPLAYER (PeerJS) & AR (WebXR)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    const mp = {
      peer: null,
      conn: [],
      id: null,
      peers: {}, // { id: { mesh, data, color } }
      isHost: false,
      color: '#' + Math.floor(Math.random() * 16777215).toString(16),
      room: null
    };

    // Toggle MP Menu
    $('mp-btn').addEventListener('click', () => $('mp-menu').classList.toggle('visible'));

    // Create Room (Random 4-char code for simplicity)
    $('mp-create').addEventListener('click', () => {
      const code = Math.random().toString(36).substring(2, 6).toUpperCase();
      initPeer(code, true);
    });

    // Join Room
    $('mp-join').addEventListener('click', () => {
      const room = $('mp-room').value.trim().toUpperCase();
      if (room) initPeer(room, false);
    });

    // Copy Invite Link
    const copyBtn = document.createElement('button');
    copyBtn.id = 'mp-copy';
    copyBtn.innerText = 'üîó Copy Invite Link';
    copyBtn.style.display = 'none'; // Hidden until connected
    copyBtn.addEventListener('click', () => {
      const url = `${window.location.origin}${window.location.pathname}?room=${mp.room}`;
      navigator.clipboard.writeText(url);
      showVoiceFeedback('üìã Link copied to clipboard!');
    });
    $('mp-menu').appendChild(copyBtn);

    function initPeer(roomId, isHost) {
      // Use public PeerServer
      mp.peer = new Peer(roomId, {
        debug: 1,
        config: { 'iceServers': [{ 'urls': 'stun:stun.l.google.com:19302' }] }
      });

      mp.peer.on('open', (id) => {
        mp.id = id;
        mp.isHost = isHost;
        mp.room = id;

        // Update UI
        $('mp-status').innerHTML = `Room: <b>${id}</b><br>Status: Connected (You)`;
        $('mp-room').value = id;
        $('mp-create').style.display = 'none';
        $('mp-join').style.display = 'none';
        copyBtn.style.display = 'block';
        $('mp-btn').classList.add('mp-connected');

        showVoiceFeedback(isHost ? `Created Room: ${id}` : `Joined Room: ${id}`);
        startSyncLoop();

        // Update URL without reload
        const newUrl = `${window.location.pathname}?room=${id}`;
        window.history.pushState({ path: newUrl }, '', newUrl);
      });

      mp.peer.on('connection', (conn) => {
        setupConnection(conn);
      });

      mp.peer.on('error', (err) => {
        console.error(err);
        $('mp-status').innerText = `Error: ${err.type} - Try another code`;
        if (err.type === 'unavailable-id') {
          // If ID taken, maybe we are joining? Try connecting to it as client
          if (isHost) {
            console.log("ID taken, joining as client instead...");
            mp.peer.destroy();
            initPeer(roomId, false);
          }
        }
      });

      if (!isHost && roomId) {
        // If joining, connect to host
        // Wait briefly for peer to open
        setTimeout(() => {
          const conn = mp.peer.connect(roomId);
          setupConnection(conn);
        }, 1000);
      }
    }

    function setupConnection(conn) {
      mp.conn.push(conn);

      conn.on('open', () => {
        // Send our color
        conn.send({ type: 'init', color: mp.color, id: mp.id });
        const count = mp.conn.length + 1; // +1 for self
        $('mp-status').innerHTML = `Room: <b>${mp.room}</b><br>Users: ${count}`;
        showVoiceFeedback(`üë§ Peer connected! (${count} users)`);
      });

      conn.on('data', (data) => {
        handlePeerData(conn.peer, data);
      });

      conn.on('close', () => {
        removePeerAvatar(conn.peer);
        const count = mp.conn.length + 1;
        $('mp-status').innerHTML = `Room: <b>${mp.room}</b><br>Users: ${count}`;
      });
    }

    function handlePeerData(peerId, data) {
      if (data.type === 'init') {
        if (!mp.peers[peerId]) createPeerAvatar(peerId, data.color);
      } else if (data.type === 'sync') {
        updatePeerPose(peerId, data.pos, data.rot);
      }
    }

    // Telepresence: Sync Position/Rotation
    function startSyncLoop() {
      setInterval(() => {
        if (!mp.conn.length) return;

        let pos, rot;
        if (camera3D) {
          pos = camera3D.position.toArray();
          rot = camera3D.quaternion.toArray();
        } else if (graph3D) {
          // ForceGraph3D camera access
          const cam = graph3D.camera();
          pos = [cam.position.x, cam.position.y, cam.position.z];
          rot = [cam.quaternion.x, cam.quaternion.y, cam.quaternion.z, cam.quaternion.w];
        } else {
          return;
        }

        const payload = { type: 'sync', pos, rot };
        mp.conn.forEach(c => c.send(payload));
      }, 50); // 20 updates/sec
    }

    function createPeerAvatar(id, color) {
      // Simple sphere avatar
      const geometry = new THREE.SphereGeometry(2, 16, 16); // Size 2
      const material = new THREE.MeshBasicMaterial({ color: color });
      const mesh = new THREE.Mesh(geometry, material);

      // Inject into current scene
      if (scene3D) {
        scene3D.add(mesh);
      } else if (graph3D) {
        graph3D.scene().add(mesh);
      }

      mp.peers[id] = { mesh, data: {} };
    }

    function updatePeerPose(id, pos, rot) {
      const peer = mp.peers[id];
      if (!peer || !peer.mesh) return;

      peer.mesh.position.set(pos[0], pos[1], pos[2]);
      peer.mesh.quaternion.set(rot[0], rot[1], rot[2], rot[3]);
    }

    function removePeerAvatar(id) {
      if (mp.peers[id]) {
        const mesh = mp.peers[id].mesh;
        if (mesh.parent) mesh.parent.remove(mesh);
        delete mp.peers[id];
      }
    }

    // AR Button Logic
    $('ar-btn').addEventListener('click', () => {
      if (!renderer3D) return;

      // Enable XR
      renderer3D.xr.enabled = true;
      document.body.appendChild(THREE.ARButton.createButton(renderer3D));

      showVoiceFeedback('ü•Ω AR Mode Ready - Click "START AR" at bottom');
    });

    // AUTO-JOIN from URL
    const urlParams = new URLSearchParams(window.location.search);
    const urlRoom = urlParams.get('room');
    if (urlRoom) {
      // Auto-join if room param exists
      console.log('üîó Auto-joining room:', urlRoom);
      setTimeout(() => initPeer(urlRoom, false), 1000); // 1s delay for PeerJS to lo
    }
  </script>
</body>

</html>
